{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"map_scatter <p>Rule-based object scattering for games and tools.</p> <p>Place assets across 2D maps and 3D surfaces using data-driven rules and sampling strategies.</p> Getting Started Core Concepts"},{"location":"#overview","title":"Overview","text":"<p>map_scatter is a Rust workspace for fast, deterministic placement in 2D domains (or 2D projections of 3D worlds). It answers a simple question: given a domain and a set of rules, where should each kind of thing appear? You describe rules as field graphs, pick sampling strategies, and get placements you can turn into entities, props, decals, or tooling data.</p>"},{"location":"#what-you-can-build","title":"What you can build","text":"<ul> <li>World detail layers: trees, rocks, grass, debris, decals, and props.</li> <li>Gameplay distribution: resources, pickups, spawn points, and points of interest.</li> <li>Authoring tooling: bake placements or masks for editors and pipelines.</li> <li>Layered effects: use overlays to drive secondary passes like ground cover.</li> </ul>"},{"location":"#use-in-2d-25d-and-3d","title":"Use in 2D, 2.5D, and 3D","text":"<ul> <li>2D: treat the domain as your map; placements are <code>Vec2</code> world positions.</li> <li>2.5D: run on a 2D domain, gate by height or slope textures, then lift placements to 3D using a heightmap or raycast.</li> <li>3D: project your surface into 2D (terrain UVs or top-down projection), run a scatter pass, then convert placements back to 3D and align to normals. For multiple surfaces, run multiple passes.</li> </ul> <p>The workflow is always the same: project to a 2D domain, scatter, then lift back to your world.</p> <p></p> <p>See the 2D, 2.5D, and 3D usage guide for practical workflows.</p>"},{"location":"#why-map_scatter","title":"Why map_scatter","text":"<ul> <li>Rule-based placement: author fields and gates instead of hand-coded loops.</li> <li>Multiple sampling strategies: blue-noise, grids, clustered, low-discrepancy, and more.</li> <li>Deterministic results: same inputs + seed = identical output.</li> <li>Layered control: order kinds, reuse overlays, and compose rules.</li> <li>Scales to large worlds: chunked evaluation and caching keep runs predictable.</li> </ul>"},{"location":"#typical-workflow","title":"Typical workflow","text":"<ol> <li>Define one or more kinds with field graphs.</li> <li>Pick a sampling strategy per layer.</li> <li>Assemble layers into a plan.</li> <li>Run the plan with textures, cache, and a run configuration.</li> <li>Use placements and optional overlay masks to drive your game or tooling.</li> </ol>"},{"location":"#scope","title":"Scope","text":"<p>map_scatter focuses on placement logic. It does not render, generate terrain, or manage assets for you. You supply the domain, textures, and the logic that turns placements into entities or gameplay. It also does not provide full volumetric 3D scattering out of the box; treat it as a surface or projection based system.</p>"},{"location":"#choose-your-entry-point","title":"Choose your entry point","text":"<ul> <li>Core library: use <code>map_scatter</code> directly in Rust tools or pipelines.</li> <li>Bevy plugin: use <code>bevy_map_scatter</code> for asset-driven authoring and ECS integration.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<ul> <li>Core library: <code>crates/map_scatter</code></li> <li>Bevy integration: <code>crates/bevy_map_scatter</code></li> <li>Examples: <code>crates/map_scatter_examples</code> and <code>crates/bevy_map_scatter_examples</code></li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>API docs: https://docs.rs/map_scatter</li> <li>Crate: https://crates.io/crates/map_scatter</li> <li>Repository: https://github.com/morgenthum/map_scatter</li> </ul>"},{"location":"2d-3d/","title":"2D, 2.5D, and 3D usage","text":"<p>map_scatter evaluates positions in a 2D domain. The difference between 2D, 2.5D, and 3D is how you map your world to that domain and how you lift placements back into your scene.</p>"},{"location":"2d-3d/#2d-maps","title":"2D maps","text":"<ul> <li>Define the playable area with <code>RunConfig::domain_extent</code> and <code>RunConfig::domain_center</code>.</li> <li>Use textures or fields for masks, biomes, densities, and gameplay zones.</li> <li>Convert placements directly to your world coordinates (they are <code>Vec2</code> positions).</li> </ul>"},{"location":"2d-3d/#25d-heightmapped-worlds","title":"2.5D heightmapped worlds","text":"<ul> <li>Use a top-down projection as the 2D domain.</li> <li>Provide height or slope textures to gate or weight placements.</li> <li>After scatter, sample the heightmap (or raycast) to lift placements to <code>Vec3</code> and align them to the terrain normal.</li> </ul>"},{"location":"2d-3d/#3d-surfaces","title":"3D surfaces","text":"<ul> <li>Choose a 2D parameterization per surface: UVs, top-down projection, or a custom atlas.</li> <li>Run a scatter pass per surface, or pack multiple surfaces into a shared 2D domain.</li> <li>Reproject placements back onto the surface with barycentric lookup or raycasts, then orient to the surface normal.</li> </ul>"},{"location":"2d-3d/#workflow-summary","title":"Workflow summary","text":"<ol> <li>Project your surface or map to a 2D domain.</li> <li>Evaluate the scatter plan with textures and samplers.</li> <li>Convert placements back to your world coordinates.</li> </ol>"},{"location":"2d-3d/#tips-and-patterns","title":"Tips and patterns","text":"<ul> <li>Use overlays to coordinate multi-pass layering (for example: rock mask drives grass suppression).</li> <li>Keep deterministic seeds for streaming and reproducible builds.</li> <li>Shift <code>RunConfig::domain_center</code> to stream around a moving origin.</li> </ul>"},{"location":"2d-3d/#related-docs","title":"Related docs","text":"<ul> <li>Core Concepts</li> <li>Bevy Integration</li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>map_scatter separates candidate generation from evaluation, then executes compiled field graphs in chunks for deterministic, scalable performance.</p>"},{"location":"architecture/#core-components","title":"Core components","text":"<ul> <li>Sampling</li> <li><code>PositionSampling</code> generates candidate positions for each layer.</li> <li>Planning</li> <li><code>Kind</code> defines field logic for one category.</li> <li><code>Layer</code> combines kinds with a sampling strategy.</li> <li><code>Plan</code> orders layers and drives execution.</li> <li>Evaluation</li> <li><code>ScatterRunner</code> orchestrates the run.</li> <li><code>Evaluator</code> executes gate and probability fields per kind.</li> <li>Field graph</li> <li><code>FieldGraphSpec</code> describes nodes and semantics.</li> <li><code>FieldProgram</code> is the compiled representation.</li> <li><code>FieldRuntime</code> samples the program over a spatial domain.</li> <li><code>FieldProgramCache</code> keeps compiled programs reusable across runs.</li> <li>Textures and overlays</li> <li><code>TextureRegistry</code> provides external data sources.</li> <li>Overlay masks are generated per layer as <code>mask_&lt;layer_id&gt;</code> textures.</li> </ul>"},{"location":"architecture/#end-to-end-flow","title":"End-to-end flow","text":"<ol> <li>Plan setup: build a <code>Plan</code> from one or more layers.</li> <li>Candidate generation: each layer's sampler produces positions.</li> <li>Compile or fetch: field graphs compile into programs, cached by kind.</li> <li>Evaluate: gate fields allow or reject, probability fields weight selection.</li> <li>Select and place: a selection strategy picks a kind per position.</li> <li>Overlays (optional): a mask is rasterized from placements.</li> <li>Results: placements, overlays, and counts are returned.</li> </ol>"},{"location":"architecture/#chunked-evaluation-and-caching","title":"Chunked evaluation and caching","text":"<p>The domain is divided into chunks, allowing field graphs to be evaluated in manageable blocks. Raster cells are sampled at a fixed resolution, and a small halo avoids artifacts at chunk borders. This approach keeps memory usage predictable and enables streaming workflows.</p>"},{"location":"architecture/#determinism","title":"Determinism","text":"<p>A run is deterministic when the plan, inputs, and seed are the same. Changing textures, order, or configuration changes the output, while repeated runs with identical inputs are stable.</p>"},{"location":"architecture/#observability","title":"Observability","text":"<p><code>ScatterEvent</code> streams allow you to inspect warnings, per-position evaluations, and overlay creation. This is useful for tooling and debugging.</p>"},{"location":"bevy/","title":"Bevy Integration","text":"<p><code>bevy_map_scatter</code> wraps the core crate with asset loading, async execution, and ECS-friendly results.</p>"},{"location":"bevy/#install","title":"Install","text":"<pre><code>[dependencies]\nbevy = \"0.18\"\nbevy_map_scatter = \"0.4\"\n</code></pre> <p>The plugin enables <code>serde</code> and <code>ron</code> by default so you can author <code>*.scatter</code> assets.</p>"},{"location":"bevy/#add-the-plugin","title":"Add the plugin","text":"<pre><code>use bevy::prelude::*;\nuse bevy_map_scatter::prelude::*;\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_plugins(MapScatterPlugin)\n        .run();\n}\n</code></pre>"},{"location":"bevy/#author-a-scatter-plan-ron","title":"Author a scatter plan (RON)","text":"<p>Plans are assets. Create a file like <code>assets/simple.scatter</code>:</p> <pre><code>(\n  layers: [\n    (\n      id: \"trees\",\n      kinds: [\n        (\n          id: \"tree\",\n          spec: (\n            nodes: {\n              \"probability\": Constant(\n                params: ConstantParams(value: 1.0),\n              ),\n            },\n            semantics: {\n              \"probability\": Probability,\n            },\n          ),\n        ),\n      ],\n      sampling: PoissonDisk(\n        radius: 2.5,\n      ),\n      selection_strategy: WeightedRandom,\n    ),\n  ],\n)\n</code></pre>"},{"location":"bevy/#trigger-a-run","title":"Trigger a run","text":"<p>Load the plan and send a <code>ScatterRequest</code> once it is ready:</p> <pre><code>use bevy::prelude::*;\nuse bevy_map_scatter::prelude::*;\n\n#[derive(Resource, Default)]\nstruct PlanHandle(Handle&lt;ScatterPlanAsset&gt;);\n\nfn load_plan(mut handle: ResMut&lt;PlanHandle&gt;, assets: Res&lt;AssetServer&gt;) {\n    handle.0 = assets.load(\"simple.scatter\");\n}\n\nfn trigger_request(\n    mut commands: Commands,\n    mut once: Local&lt;bool&gt;,\n    handle: Res&lt;PlanHandle&gt;,\n    assets: Res&lt;Assets&lt;ScatterPlanAsset&gt;&gt;,\n) {\n    if *once || assets.get(&amp;handle.0).is_none() {\n        return;\n    }\n\n    let domain = Vec2::new(100.0, 100.0);\n    let config = RunConfig::new(domain)\n        .with_chunk_extent(32.0)\n        .with_raster_cell_size(1.0);\n\n    let entity = commands.spawn_empty().id();\n    commands.trigger(ScatterRequest::new(entity, handle.0.clone(), config, 123));\n\n    *once = true;\n}\n\nfn on_finished(finished: On&lt;ScatterFinished&gt;) {\n    info!(\"Placed {} instances\", finished.result.placements.len());\n}\n</code></pre>"},{"location":"bevy/#register-textures","title":"Register textures","text":"<p>To use Bevy <code>Image</code> assets inside field graphs, snapshot them to <code>ImageTexture</code> and register them in the shared registry. The registry is an <code>Arc&lt;TextureRegistry&gt;</code>, so use <code>Arc::make_mut</code> to register.</p> <pre><code>use std::sync::Arc;\nuse bevy::prelude::*;\nuse bevy_map_scatter::prelude::*;\n\n#[derive(Resource)]\nstruct HeightmapHandle(Handle&lt;Image&gt;);\n\nfn register_textures(\n    mut registry: ResMut&lt;ScatterTextureRegistry&gt;,\n    images: Res&lt;Assets&lt;Image&gt;&gt;,\n    handle: Res&lt;HeightmapHandle&gt;,\n) {\n    let Some(image) = images.get(&amp;handle.0) else {\n        return;\n    };\n\n    let Some(texture) = ImageTexture::from_image(image, Vec2::new(100.0, 100.0)) else {\n        return;\n    };\n\n    Arc::make_mut(&amp;mut registry.0).register(\"heightmap\", texture);\n}\n</code></pre> <p>If the source image changes, create a new <code>ImageTexture</code> snapshot and re-register it.</p>"},{"location":"bevy/#streaming-optional","title":"Streaming (optional)","text":"<p>For large or moving worlds, enable chunked streaming around an anchor entity:</p> <ul> <li>Add <code>MapScatterStreamingPlugin</code>.</li> <li>Attach <code>ScatterStreamSettings</code> to an entity that moves through the world.</li> <li>Listen for <code>ScatterStreamPlacement</code> components on spawned entities.</li> </ul>"},{"location":"bevy/#tips","title":"Tips","text":"<ul> <li>Use deterministic seeds during development to compare changes.</li> <li>Keep domain sizes consistent with texture mappings.</li> <li>Use overlay masks to prevent overlap between layers.</li> <li>Inspect <code>ScatterMessage</code> events for diagnostics.</li> </ul>"},{"location":"bevy/#examples","title":"Examples","text":"<ul> <li><code>cargo run -p bevy_map_scatter_examples --bin quick-start</code></li> <li><code>cargo run -p bevy_map_scatter_examples --bin streaming-minimal</code></li> </ul>"},{"location":"concepts/","title":"Core Concepts","text":"<p>This page describes the building blocks of map_scatter and how they fit together.</p>"},{"location":"concepts/#domain-and-coordinates","title":"Domain and coordinates","text":"<p>Scatter runs operate on a 2D domain described by <code>RunConfig::domain_extent</code> and <code>RunConfig::domain_center</code>. Positions are <code>Vec2</code> values in world units. If you are working in 3D, project your world into a 2D plane and use textures or fields for height/slope constraints.</p>"},{"location":"concepts/#kinds","title":"Kinds","text":"<p>A kind represents one category of placement (for example: grass, rocks, props). Each kind has an id and a field graph that determines where it is allowed and how likely it is to appear.</p>"},{"location":"concepts/#field-graphs-and-semantics","title":"Field graphs and semantics","text":"<p>A field graph is a small dataflow graph of <code>NodeSpec</code> nodes. Each node computes a value per position, often based on textures or other fields.</p> <p>Two semantics drive evaluation:</p> <ul> <li>Gate: a field tagged as <code>Gate</code> must be positive for a placement to be allowed.</li> <li>Probability: a field tagged as <code>Probability</code> becomes the placement weight in <code>[0, 1]</code>.</li> </ul> <p>If a kind has no probability field, a default weight is used. Gates are evaluated first; if any gate is not positive, the position is rejected.</p>"},{"location":"concepts/#sampling","title":"Sampling","text":"<p>Sampling strategies generate candidate positions across the domain. You can choose from multiple styles such as grid-based, blue-noise/Poisson, clustered, and low-discrepancy samplers. Sampling is independent from field evaluation, which means you can swap distribution styles without rewriting your field logic.</p>"},{"location":"concepts/#layers-and-plans","title":"Layers and plans","text":"<p>A layer combines a sampling strategy with one or more kinds. Layers are ordered in a plan, and each layer can optionally emit an overlay mask for later layers to read.</p> <p>When multiple kinds are allowed at a position, the selection strategy decides what gets placed:</p> <ul> <li><code>WeightedRandom</code> (default)</li> <li><code>HighestProbability</code></li> </ul>"},{"location":"concepts/#textures-and-overlays","title":"Textures and overlays","text":"<p>Textures provide external data to field graphs via the <code>TextureRegistry</code>. Overlays are generated masks from previous layers and are registered as textures named <code>mask_&lt;layer_id&gt;</code>.</p> <p>In Bevy, use <code>ImageTexture</code> to snapshot <code>Image</code> assets into CPU-side textures that can be registered with the <code>ScatterTextureRegistry</code> resource.</p>"},{"location":"concepts/#determinism-and-streaming","title":"Determinism and streaming","text":"<p>Determinism comes from combining a fixed RNG seed with a stable plan and input textures. Chunked evaluation keeps memory usage predictable and supports streaming around a moving origin by shifting <code>domain_center</code>.</p>"},{"location":"concepts/#events-and-observability","title":"Events and observability","text":"<p>Scatter runs can emit <code>ScatterEvent</code> values (start, finish, per-position evaluation, overlays, warnings). Use <code>VecSink</code>, <code>FnSink</code>, or custom sinks to collect data for logs, tools, or debugging.</p>"},{"location":"quickstart/","title":"Getting Started","text":"<p>This page gets you from zero to a working scatter run. Choose the core library if you want a lightweight Rust API, or the Bevy plugin if you want asset-driven authoring and ECS integration.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust 1.89 (see <code>rust-toolchain.toml</code>)</li> <li>Basic familiarity with Rust and Cargo</li> </ul>"},{"location":"quickstart/#install","title":"Install","text":"Core libraryBevy plugin <pre><code>[dependencies]\nmap_scatter = \"0.4\"\nrand = \"0.9\"\nglam = { version = \"0.30\", features = [\"mint\"] }\nmint = \"0.5\"\n</code></pre> <p>Optional features:</p> <ul> <li><code>map_scatter = { version = \"0.4\", features = [\"serde\"] }</code> to enable <code>serde</code> support.</li> </ul> <pre><code>[dependencies]\nbevy = \"0.18\"\nbevy_map_scatter = \"0.4\"\n</code></pre> <p>Optional:</p> <ul> <li>Add <code>map_scatter = \"0.4\"</code> if you want core types directly.</li> </ul>"},{"location":"quickstart/#hello-scatter","title":"Hello, scatter","text":"Core libraryBevy plugin <pre><code>use glam::Vec2;\nuse rand::{rngs::StdRng, SeedableRng};\n\nuse map_scatter::prelude::*;\n\nfn main() {\n    // 1) Author a field graph for a \"kind\".\n    let mut spec = FieldGraphSpec::default();\n    spec.add_with_semantics(\n        \"probability\",\n        NodeSpec::constant(1.0),\n        FieldSemantics::Probability,\n    );\n    let grass = Kind::new(\"grass\", spec);\n\n    // 2) Build a layer using a sampling strategy (jittered grid here).\n    let layer = Layer::new_with(\n        \"grass\",\n        vec![grass],\n        JitterGridSampling::new(0.35, 5.0),\n    )\n    // Optional: produce an overlay mask to reuse in later layers.\n    .with_overlay((256, 256), 3);\n\n    // 3) Assemble a plan (one or more layers).\n    let plan = Plan::new().with_layer(layer);\n\n    // 4) Prepare runtime.\n    let mut cache = FieldProgramCache::new();\n    let textures = TextureRegistry::new();\n    let cfg = RunConfig::new(Vec2::new(100.0, 100.0))\n        .with_chunk_extent(32.0)\n        .with_raster_cell_size(1.0)\n        .with_grid_halo(2);\n\n    // 5) Run.\n    let mut rng = StdRng::seed_from_u64(42);\n    let mut runner = ScatterRunner::new(cfg, &amp;textures, &amp;mut cache);\n    let result = runner.run(&amp;plan, &amp;mut rng);\n\n    println!(\n        \"Placed {} instances (evaluated: {}, rejected: {}).\",\n        result.placements.len(),\n        result.positions_evaluated,\n        result.positions_rejected\n    );\n}\n</code></pre> <p>Create a scatter plan in <code>assets/simple.scatter</code>:</p> <pre><code>(\n  layers: [\n    (\n      id: \"dots\",\n      kinds: [\n        (\n          id: \"dots\",\n          spec: (\n            nodes: {\n              \"probability\": Constant(\n                params: ConstantParams(value: 1.0),\n              ),\n            },\n            semantics: {\n              \"probability\": Probability,\n            },\n          ),\n        ),\n      ],\n      sampling: JitterGrid(\n        jitter: 1.0,\n        cell_size: 1.0,\n      ),\n      selection_strategy: WeightedRandom,\n    ),\n  ],\n)\n</code></pre> <p>Trigger a scatter run once the asset is loaded:</p> <pre><code>use bevy::prelude::*;\nuse bevy_map_scatter::prelude::*;\n\n#[derive(Resource, Default)]\nstruct PlanHandle(Handle&lt;ScatterPlanAsset&gt;);\n\nfn main() {\n    App::new()\n        .init_resource::&lt;PlanHandle&gt;()\n        .add_plugins(DefaultPlugins)\n        .add_plugins(MapScatterPlugin)\n        .add_systems(Startup, load_plan)\n        .add_systems(Update, trigger_request)\n        .add_observer(log_finished)\n        .run();\n}\n\nfn load_plan(mut handle: ResMut&lt;PlanHandle&gt;, assets: Res&lt;AssetServer&gt;) {\n    handle.0 = assets.load(\"simple.scatter\");\n}\n\nfn trigger_request(\n    mut commands: Commands,\n    mut once: Local&lt;bool&gt;,\n    handle: Res&lt;PlanHandle&gt;,\n    assets: Res&lt;Assets&lt;ScatterPlanAsset&gt;&gt;,\n) {\n    if *once || assets.get(&amp;handle.0).is_none() {\n        return;\n    }\n\n    let domain = Vec2::new(10.0, 10.0);\n    let config = RunConfig::new(domain)\n        .with_chunk_extent(domain.x)\n        .with_raster_cell_size(1.0);\n\n    let entity = commands.spawn_empty().id();\n    commands.trigger(ScatterRequest::new(entity, handle.0.clone(), config, 42));\n\n    *once = true;\n}\n\nfn log_finished(finished: On&lt;ScatterFinished&gt;, mut commands: Commands) {\n    info!(\n        \"Scatter run {} finished: placements={} evaluated={} rejected={}\",\n        finished.entity,\n        finished.result.placements.len(),\n        finished.result.positions_evaluated,\n        finished.result.positions_rejected\n    );\n\n    commands.entity(finished.entity).despawn();\n}\n</code></pre>"},{"location":"quickstart/#run-examples","title":"Run examples","text":"<ul> <li>Core library: <code>cargo run -p map_scatter_examples --bin samplers-poisson-basic</code></li> <li>Bevy: <code>cargo run -p bevy_map_scatter_examples --bin quick-start</code></li> </ul> <p>See <code>crates/map_scatter_examples/src/bin</code> and <code>crates/bevy_map_scatter_examples/src/bin</code> for the full list.</p>"},{"location":"quickstart/#next-steps","title":"Next steps","text":"<ul> <li>Read the Concepts page to understand field graphs and layers.</li> <li>Follow the Bevy Integration guide for asset workflows and streaming.</li> <li>Review the Architecture overview for a deeper model of the pipeline.</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This page highlights the most important entry points, configuration knobs, and compatibility notes. For full API details, see the docs.rs pages linked below.</p>"},{"location":"reference/#core-api-entry-points","title":"Core API entry points","text":"<ul> <li><code>FieldGraphSpec</code>, <code>NodeSpec</code>, <code>FieldSemantics</code>: author field graphs.</li> <li><code>Kind</code>, <code>Layer</code>, <code>Plan</code>: structure your scatter plan.</li> <li><code>PositionSampling</code>: trait implemented by sampling strategies.</li> <li><code>RunConfig</code>, <code>ScatterRunner</code>, <code>RunResult</code>: execute plans and inspect results.</li> <li><code>TextureRegistry</code>, <code>Texture</code>, <code>TextureChannel</code>: provide external data to fields.</li> <li><code>FieldProgramCache</code>: reuse compiled programs across runs.</li> </ul>"},{"location":"reference/#runconfig-tuning","title":"RunConfig tuning","text":"<ul> <li><code>domain_extent</code>: size of the evaluated area in world units.</li> <li><code>domain_center</code>: world-space center of the domain (useful for streaming).</li> <li><code>chunk_extent</code>: chunk size in world units; larger chunks reduce overhead but increase per-chunk work.</li> <li><code>raster_cell_size</code>: resolution of field sampling; smaller values increase accuracy at higher cost.</li> <li><code>grid_halo</code>: extra cells around chunks for filters and EDT.</li> </ul>"},{"location":"reference/#events-and-diagnostics","title":"Events and diagnostics","text":"<ul> <li>Use <code>ScatterRunner::run_with_events</code> with <code>VecSink</code> or <code>FnSink</code> to observe placements, warnings, overlays, and per-position evaluations.</li> <li>In Bevy, listen to <code>ScatterMessage</code> for streaming diagnostics or pipeline telemetry.</li> </ul>"},{"location":"reference/#feature-flags","title":"Feature flags","text":"<ul> <li><code>map_scatter</code>:</li> <li><code>serde</code> enables serialization of field graph specs and textures.</li> <li><code>bevy_map_scatter</code>:</li> <li><code>serde</code> and <code>ron</code> are enabled by default for <code>*.scatter</code> assets.</li> </ul>"},{"location":"reference/#version-compatibility","title":"Version compatibility","text":"bevy_map_scatter map_scatter bevy 0.4 0.4 0.18"},{"location":"reference/#links","title":"Links","text":"<ul> <li>Core API: https://docs.rs/map_scatter</li> <li>Bevy API: https://docs.rs/bevy_map_scatter</li> <li>Examples: https://github.com/morgenthum/map_scatter/tree/main/crates/map_scatter_examples</li> </ul>"}]}