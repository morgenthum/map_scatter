use glam::Vec2;
use map_scatter::prelude::*;
use map_scatter_examples::{init_tracing, render_run_result_to_png, KindStyle, RenderConfig};
use rand::rngs::StdRng;
use rand::SeedableRng;

/// A single-channel raster grid texture that encodes a road exclusion mask:
/// - 1.0 on/near the road corridor (excluded)
/// - 0.0 elsewhere (allowed)
///
/// The grid is generated by sampling each texel center's world position and
/// computing its distance to a polyline path. Values are written with an
/// optional feather for a soft edge.
struct RoadMaskGrid {
    origin: Vec2,
    extent: Vec2,
    width: u32,
    height: u32,
    data: Vec<f32>, // 1 = road (exclude), 0 = non-road (allow)
}

impl RoadMaskGrid {
    fn from_polyline(
        domain_extent: Vec2,
        width: u32,
        height: u32,
        path: &[Vec2],
        half_width: f32,
        feather: f32,
    ) -> Self {
        let origin = Vec2::new(-domain_extent.x * 0.5, -domain_extent.y * 0.5);
        let extent = domain_extent;

        let mut data = vec![0.0; (width as usize) * (height as usize)];

        // Precompute for sampling
        let inside_r = (half_width - feather).max(0.0);
        for y in 0..height {
            for x in 0..width {
                let u = (x as f32 + 0.5) / (width as f32);
                let v = (y as f32 + 0.5) / (height as f32);
                let wx = origin.x + u * extent.x;
                let wy = origin.y + v * extent.y;
                let p = Vec2::new(wx, wy);

                let d = distance_to_polyline(p, path).unwrap_or(f32::INFINITY);

                let val = if d <= inside_r {
                    1.0
                } else if d >= half_width {
                    0.0
                } else {
                    // Feather band: map d in [inside_r, half_width] to weight in [1..0] smoothly
                    let t = ((half_width - d) / feather).clamp(0.0, 1.0);
                    smoothstep01(t)
                };

                data[(y as usize) * (width as usize) + (x as usize)] = val;
            }
        }

        Self {
            origin,
            extent,
            width,
            height,
            data,
        }
    }

    #[inline]
    fn sample_nearest(&self, p: Vec2) -> f32 {
        if self.width == 0 || self.height == 0 {
            return 0.0;
        }
        let u = if self.extent.x != 0.0 {
            ((p.x - self.origin.x) / self.extent.x).clamp(0.0, 1.0)
        } else {
            0.0
        };
        let v = if self.extent.y != 0.0 {
            ((p.y - self.origin.y) / self.extent.y).clamp(0.0, 1.0)
        } else {
            0.0
        };

        let x = ((u * self.width as f32) as u32).min(self.width - 1);
        let y = ((v * self.height as f32) as u32).min(self.height - 1);
        self.data[(y as usize) * (self.width as usize) + (x as usize)]
    }
}

impl Texture for RoadMaskGrid {
    fn sample(&self, channel: TextureChannel, p: Vec2) -> f32 {
        match channel {
            // Road exclusion mask lives in the R channel.
            TextureChannel::R => self.sample_nearest(p),
            // Alpha as "present"
            TextureChannel::A => 1.0,
            _ => 0.0,
        }
    }
}

/// Distance from a point to a polyline (min over segments).
/// Returns None if fewer than 2 points (no segments).
fn distance_to_polyline(p: Vec2, path: &[Vec2]) -> Option<f32> {
    if path.len() < 2 {
        return None;
    }
    let mut best = f32::INFINITY;
    for i in 0..(path.len() - 1) {
        let a = path[i];
        let b = path[i + 1];
        let d = distance_point_to_segment(p, a, b);
        if d < best {
            best = d;
        }
    }
    Some(best)
}

/// Euclidean distance from point P to segment AB.
fn distance_point_to_segment(p: Vec2, a: Vec2, b: Vec2) -> f32 {
    let ab = b - a;
    let ap = p - a;
    let ab_len2 = ab.length_squared();
    if ab_len2 == 0.0 {
        return ap.length();
    }
    let t = (ap.dot(ab) / ab_len2).clamp(0.0, 1.0);
    let closest = a + t * ab;
    (p - closest).length()
}

#[inline]
fn smoothstep01(t: f32) -> f32 {
    let t = t.clamp(0.0, 1.0);
    t * t * (3.0 - 2.0 * t)
}

fn main() -> anyhow::Result<()> {
    init_tracing();
    // 1) Domain setup
    let domain_extent = Vec2::new(100.0, 100.0);

    // 2) Define a simple "road" polyline in world space (centered domain).
    //    This could represent an S-curve road or path across the map.
    let road: Vec<Vec2> = vec![
        Vec2::new(-40.0, -30.0),
        Vec2::new(-20.0, -10.0),
        Vec2::new(0.0, 0.0),
        Vec2::new(18.0, 12.0),
        Vec2::new(40.0, 22.0),
    ];

    // Road parameters (world units)
    let road_half_width = 5.0;
    let road_edge_feather = 2.0;

    // 3) Bake a grid that encodes the road corridor as an exclusion mask (1 = road, 0 = not road).
    let grid = RoadMaskGrid::from_polyline(
        domain_extent,
        256,
        256,
        &road,
        road_half_width,
        road_edge_feather,
    );

    // 4) Register the grid as a texture
    let mut textures = TextureRegistry::new();
    textures.register("road_mask", grid);

    // 5) Field graph (moved into helper): see off_road_kind()
    let kind = off_road_kind();

    let plan = Plan::new().with_layer(Layer::new(
        "off_road",
        vec![kind],
        Box::new(PoissonDiskSampling::new(2.2)),
    ));

    // 6) Runner
    let config = RunConfig::new(domain_extent)
        .with_chunk_extent(100.0)
        .with_raster_cell_size(1.0)
        .with_grid_halo(2);

    let cache = FieldProgramCache::new();
    let mut rng = StdRng::seed_from_u64(42);
    let mut runner = ScatterRunner::try_new(config, &textures, &cache)?;
    let result = runner.run(&plan, &mut rng);

    // 7) Render
    render(&result)?;
    Ok(())
}

fn off_road_kind() -> Kind {
    let mut spec = FieldGraphSpec::default();
    spec.add(
        "road_raw",
        NodeSpec::texture("road_mask", TextureChannel::R),
    );
    spec.add_with_semantics(
        "gate",
        NodeSpec::invert("road_raw".into()),
        FieldSemantics::Gate,
    );
    spec.add_with_semantics(
        "probability",
        NodeSpec::constant(1.0),
        FieldSemantics::Probability,
    );
    Kind::new("dots", spec)
}

fn render(result: &RunResult) -> anyhow::Result<()> {
    let image_size = (1000, 1000);
    let domain_extent = Vec2::new(100.0, 100.0);
    let background = [238, 240, 244];

    let mut config = RenderConfig::new(image_size, domain_extent).with_background(background);

    config.set_kind_style(
        "dots",
        KindStyle::Circle {
            color: [20, 140, 80],
            radius: 3,
        },
    );

    let out = "grids-road-exclusion-mask.png";
    render_run_result_to_png(result, &config, out)?;
    Ok(())
}
