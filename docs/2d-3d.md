# 2D, 2.5D, and 3D usage

map_scatter evaluates positions in a 2D domain. The difference between 2D, 2.5D, and 3D is how you map your world to that domain and how you lift placements back into your scene.

## 2D maps

- Define the playable area with `RunConfig::domain_extent` and `RunConfig::domain_center`.
- Use textures or fields for masks, biomes, densities, and gameplay zones.
- Convert placements directly to your world coordinates (they are `Vec2` positions).

## 2.5D heightmapped worlds

- Use a top-down projection as the 2D domain.
- Provide height or slope textures to gate or weight placements.
- After scatter, sample the heightmap (or raycast) to lift placements to `Vec3` and align them to the terrain normal.

## 3D surfaces

- Choose a 2D parameterization per surface: UVs, top-down projection, or a custom atlas.
- Run a scatter pass per surface, or pack multiple surfaces into a shared 2D domain.
- Reproject placements back onto the surface with barycentric lookup or raycasts, then orient to the surface normal.

## Workflow summary

1. Project your surface or map to a 2D domain.
2. Evaluate the scatter plan with textures and samplers.
3. Convert placements back to your world coordinates.

## Tips and patterns

- Use overlays to coordinate multi-pass layering (for example: rock mask drives grass suppression).
- Keep deterministic seeds for streaming and reproducible builds.
- Shift `RunConfig::domain_center` to stream around a moving origin.

## Related docs

- [Core Concepts](concepts.md)
- [Bevy Integration](bevy.md)
